# -*- coding: utf-8 -*-
"""Examen_Djambala_GORY_Ens.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KwILd-d_zVI1MnrGe_MPg99D6J6TGlPa

#Examen : Djambala GORY

#1. Création de la fonction mathématique: Polygone de dégré 3.

##a.Fonction Polynome: Avec l'inconnu x pour paramètre d'entrée.
"""

# a. Implémentation de la fonction : f(x)=x^3-1.5x^2-6x+5
def Polynome(x):
  y=x**3-1.5*x**2-6*x+5
  return y

# Exemple fonction Polynome :
Polynome(5) # retourne 62.5

"""##b.Fonction Factorielle: Avec n pour paramètre d'entrée"""

# b. Fonction factorielle :
def factorielle(n):
   if n == 0: # Traitement du cas où n = 0
      return 1
   else:
      F = 1
      for k in range(2,n+1): # Itération sur les valeurs de 1 à n afin d'appliquer la multiplication
         F = F * k
      return F

# Exemple fonction factorielle :

factorielle(5) # Valeur retournée est 120<=>5!

"""##c.Suite de Fibonnaci: Avec nbr le nombre saisi par l'utilisateur."""

nbr=int(input("Entrez un nombre: "))
# On définit les deux prémières valeurs de la serie de fibonacci.
n1 = 0
n2 = 1
print("\n la suite fibonacci est :")
print(n1, ",", n2, end=", ")
for i in range(2, nbr):
  next = n1 + n2
  print(next, end=", ")
  n1 = n2
  n2 = next

"""#2. Gestion des exceptions : Exemple sur la fonction factorielle."""

# Fonction de gestion de chaine de caractère :
def est_chaine(a):
  if type(a)==str:
    while type(a)==str:
      try:
        a=int(input("Veuillez entrée une valeur numérique: "))
      except ValueError:
        a=int(input("Veuillez entrée une valeur numérique : "))
  
  return a

# Fonction de gestion de nombre complexe :
def est_complexe(a):
  if (type(a)==complex) :
    a= a.real 
  else:
    a=a.real 
  return a

# Fonction gestion des valeurs négatives :
def est_negative(a):
  if a <= 0:
    while a <= 0:
      try:
        a=int(input("Saisissez une valeur positive :"))
      except ValueError:
        a=int(input("Entrée une valeur positive :"))
  return a

# Fonction de gestion des bornes :
  #Cette fonction servira à delimiter la valeur du n pour la factorisation par une borne (min,max)
  # Nous partons du principe que min < max.
def borne(a,min,max): 
  if a > max:
    while a > max:
      try:
        a=int(input("La valeur est inférieure à la limite autorisée : "))
      except ValueError:
        a=int(input("Veuillez entrée une valeur inférieure à la limite autorisée : "))
  else:
    if a < min:
        while a < min:
          try:
            a=int(input("La valeur est supérieure à la limite autorisée : "))
          except ValueError:
            a=int(input("Veuillez entrée une valeur supérieure à la limite autorisée : "))
  return a

"""## Exemple de test des fonctions de gestion"""

# Borne
borne(3,4,20)

# Chaine
est_chaine("toto")

# Complexe 
est_complexe(2+7j)

# Négative 
est_negative(-10)

# Fonction factorielle 

def g_factorielle(n):

  # appel de la fonction de vérification de valeurs chaines
  n_ch=(est_chaine(n))
 
  # appel de la fonction de vérification de valeurs complexes
  n_cpl=est_complexe(n_ch)
  
  # appel de la fonction de vérification de valeur nulle
  
  n_neg=est_negative(n_cpl)

  # appel de la fonction de vérification de valeur hors norme
  min=int(input("Entre la valeur minimun :"))
  max=int(input("Entrée la valeur maximun :"))

  if min > max :
      while min > max:
        try:
          min=int(input("La valeur du min doit-être inférieure à celle de max : "))
        except ValueError:
          min=int(input("Veuillez entrée une valeur min inférieure à max : "))
  else:
    n=borne(n_neg,min,max)


  if n == 0: # Traitement du cas où n = 0
    return 1
  else:
    F = 1
    for k in range(2,n+1): # Itération sur les valeurs de 1 à n afin d'appliquer la multiplication
        F = F * k
    return F

"""## Test de la fonction factorielle avec gestion des exceptions :"""

g_factorielle("toto")

from math import log, sqrt, pi, exp
from scipy.stats import norm
from datetime import datetime, date
import numpy as np
import pandas as pd
from pandas import DataFrame

def d1(S,K,T,r,sigma):
    return(log(S/K)+(r+sigma**2/2.)*T)/(sigma*sqrt(T))
def d2(S,K,T,r,sigma):
    return d1(S,K,T,r,sigma)-sigma*sqrt(T)

def bs_call(S,K,T,r,sigma):
    return S*norm.cdf(d1(S,K,T,r,sigma))-K*exp(-r*T)*norm.cdf(d2(S,K,T,r,sigma))
  
def bs_put(S,K,T,r,sigma):
    return K*exp(-r*T)-S+bs_call(S,K,T,r,sigma)